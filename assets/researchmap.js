const CACHE_DIR = "data/researchmap";
const CONFIG_PATH = "site.config.json";

// Load config (static)
export async function loadConfig() {
  const res = await fetch(CONFIG_PATH, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to load config: ${res.status}`);
  return await res.json();
}

// Load cached JSON generated by GitHub Actions (recommended path)
export async function loadCachedData() {
  try {
    const metaRes = await fetch(`${CACHE_DIR}/meta.json`, { cache: "no-store" });
    const meta = metaRes.ok ? await metaRes.json() : null;

    // load known files if present
    const types = meta?.types ?? ["published_papers", "presentations", "research_projects", "awards"];
    const out = { meta: meta || {} };

    await Promise.all(types.map(async (t) => {
      const r = await fetch(`${CACHE_DIR}/${t}.json`, { cache: "no-store" });
      if (r.ok) out[t] = await r.json();
      else out[t] = [];
    }));

    return out;
  } catch (e) {
    return { meta: {}, published_papers: [], presentations: [], research_projects: [], awards: [] };
  }
}

// Best-effort live fetch (works only if browser can reach api.researchmap.jp with CORS)
// If it fails, caller should keep cached data.
export async function fetchLiveData(config, { force = false } = {}) {
  const rm = config?.researchmap ?? {};
  const permalink = rm.permalink;
  const baseUrl = rm.baseUrl || "https://api.researchmap.jp";
  const types = rm.types || ["published_papers"];

  const fetchedAt = new Date().toISOString();
  const result = { meta: { fetchedAt, permalink, baseUrl, types, source: "live" } };

  for (const t of types) {
    result[t] = await fetchAllItems({ baseUrl, permalink, type: t, force });
  }

  // count
  result.meta.itemsTotal = types.reduce((sum, t) => sum + (result[t]?.length || 0), 0);
  return result;
}

async function fetchJson(url, opts = {}) {
  const res = await fetch(url, {
    ...opts,
    headers: {
      "accept": "application/json",
      ...(opts.headers || {}),
    },
  });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} for ${url}\n${text.slice(0, 200)}`);
  }
  return await res.json();
}

async function fetchAllItems({ baseUrl, permalink, type, force = false }) {
  const limit = 1000;
  // APIの start が 0/1 起点で揺れる可能性があるので自動フォールバック
  const starts = [1, 0];
  for (const start0 of starts) {
    try {
      let all = [];
      let start = start0;
      while (true) {
        const url = new URL(`${baseUrl.replace(/\/$/, "")}/${encodeURIComponent(permalink)}/${encodeURIComponent(type)}`);
        url.searchParams.set("format", "json");
        url.searchParams.set("limit", String(limit));
        url.searchParams.set("start", String(start));
        // sort は type で使える項目が違うので指定しない（必要なら site.config.json で拡張）
        if (force) url.searchParams.set("_", String(Date.now())); // bust cache

        const json = await fetchJson(url.toString());
        const items = json.items || json["@graph"] || json || [];
        const page = Array.isArray(items) ? items : (items.items || []);
        all = all.concat(page);

        if (!Array.isArray(page) || page.length < limit) break;
        start += limit;
        if (all.length > 5000) break; // safety
      }
      return all;
    } catch (e) {
      // try next start base
      continue;
    }
  }
  // if both failed, throw the last error generically
  throw new Error(`Failed to fetch ${type} for ${permalink}`);
}

// ---- normalization (API fields vary; keep it defensive) ----

function text(field) {
  if (!field) return "";
  if (typeof field === "string") return field;
  if (field.ja) return field.ja;
  if (field.en) return field.en;
  const k = Object.keys(field)[0];
  return field[k] ?? "";
}

function joinPeople(field) {
  // examples seen in community code: {ja:[{name:""}], en:[{name:""}]}
  if (!field || typeof field !== "object") return "";
  const arr = field.ja || field.en || [];
  if (!Array.isArray(arr)) return "";
  return arr.map((x) => x?.name).filter(Boolean).join(", ");
}

export function normalizeItems(items, type) {
  if (!Array.isArray(items)) return [];
  const out = items.map((it) => {
    if (!it || typeof it !== "object") return null;

    if (type === "published_papers") {
      const title = text(it.paper_title) || text(it.title) || "";
      const venue = text(it.publication_name) || text(it.journal_name) || "";
      const date = it.publication_date || it.published_date || "";
      const year = (String(date).match(/^\d{4}/) || [""])[0];
      const authors = joinPeople(it.authors) || joinPeople(it.creators) || "";
      const doi = (it.identifiers?.doi && it.identifiers.doi[0]) || it.doi || "";
      const url = (it.identifiers?.url && it.identifiers.url[0]) || it.url || "";

      return { type, title, venue, year, authors, doi, url, raw: it };
    }

    if (type === "presentations") {
      const title = text(it.presentation_title) || text(it.title) || "";
      const venue = text(it.event) || text(it.conference) || "";
      const date = it.publication_date || it.date || "";
      const year = (String(date).match(/^\d{4}/) || [""])[0];
      const authors = joinPeople(it.presenters) || joinPeople(it.authors) || "";
      const url = (it.identifiers?.url && it.identifiers.url[0]) || it.url || "";
      return { type, title, venue, year, authors, url, raw: it };
    }

    if (type === "research_projects") {
      const title = text(it.research_project_title) || text(it.project_title) || text(it.title) || "";
      const from = it.from_date || it.starting_date || it.start_date || "";
      const to = it.to_date || it.ending_date || it.end_date || "";
      const role = text(it.role) || it.role || "";
      const summary = text(it.summary) || text(it.description) || "";
      const url = (it.identifiers?.url && it.identifiers.url[0]) || it.url || "";
      return { type, title, from, to, role, summary, url, raw: it };
    }

    if (type === "awards") {
      const title = text(it.award_title) || text(it.title) || "";
      const date = it.award_date || it.publication_date || it.date || "";
      const year = (String(date).match(/^\d{4}/) || [""])[0];
      const venue = text(it.award_organization) || text(it.organization) || "";
      return { type, title, venue, year, raw: it };
    }

    // fallback
    const title = text(it.title) || text(it.name) || "";
    return { type, title, raw: it };
  }).filter(Boolean);

  // sort by year desc when possible
  out.sort((a,b) => (b.year || "").localeCompare(a.year || ""));
  return out;
}
